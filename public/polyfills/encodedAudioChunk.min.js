!function(){"use strict";globalThis.EncodedAudioChunk||(console.log("EncodedAudioChunk not supported, using polyfill"),self.EncodedAudioChunk=class{#t;#e;#r;#a;#n;constructor(t){if(!t||!t.type||!t.data)throw new TypeError("EncodedAudioChunk constructor requires type and data");if("key"!==t.type&&"delta"!==t.type)throw new TypeError("EncodedAudioChunk type must be 'key' or 'delta'");if(this.#t=t.type,this.#e=t.timestamp||0,this.#r=t.duration||0,t.data instanceof ArrayBuffer)this.#a=new Uint8Array(t.data);else{if(!ArrayBuffer.isView(t.data))throw new TypeError("EncodedAudioChunk data must be an ArrayBuffer or ArrayBufferView");this.#a=new Uint8Array(t.data.buffer,t.data.byteOffset,t.data.byteLength)}this.#n=this.#a.byteLength}get type(){return this.#t}get timestamp(){return this.#e}get duration(){return this.#r}get byteLength(){return this.#n}copyTo(t){if(!(t instanceof ArrayBuffer||ArrayBuffer.isView(t)))throw new TypeError("Destination must be an ArrayBuffer or ArrayBufferView");let e;if(e=t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.byteLength<this.#n)throw new DOMException("Destination buffer is too small","InvalidStateError");return e.set(this.#a),t}})}();
